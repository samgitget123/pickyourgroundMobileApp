import React, { useEffect, useState, useCallback } from "react";
import { useFocusEffect } from '@react-navigation/native';

// import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import Footer from "./Footer";
import {
  View,
  FlatList,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  Modal,
  TouchableOpacity,
} from "react-native";
import {
  Text,
  Button,
  TextInput,
  Card,
} from "react-native-paper";
import DateTimePicker from "@react-native-community/datetimepicker";
import { Picker } from '@react-native-picker/picker';

import * as FileSystem from "expo-file-system";
import { useApi } from "../src/contexts/ApiContext";
import AsyncStorage from '@react-native-async-storage/async-storage';
const DashboardScreen = () => {
  const [date, setDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [bookings, setBookings] = useState([]);
  const [filtered, setFiltered] = useState([]);
  const [search, setSearch] = useState({ groundId: "", bookingId: "", userName: "" });
  const [page, setPage] = useState(0);
  //View booking
  const [selectedBooking, setSelectedBooking] = useState(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [showStatusOptions, setShowStatusOptions] = useState(null); // bookingId
 const currentYear = new Date().getFullYear();
  //Power bi///

  const itemsPerPage = 5
  const { BASE_URL } = useApi();


  useFocusEffect(
    useCallback(() => {
      fetchBookings();
    }, [date, showStatusOptions]) // runs on first focus and when `date` changes
  );
  const fetchBookings = async () => {
    try {
      const storedUser = await AsyncStorage.getItem('userData');
      if (!storedUser) {
        console.warn('⚠️ No userData found in AsyncStorage');
        return;
      }

      const user = JSON.parse(storedUser);
      if (!user?.user?.id) {
        console.error('❌ Invalid user object structure:', user);
        return;
      }

      const id = user.user.id;
      //5621f3e5-9419-4ae5-816f-d04dea908af7
      const formattedDate = date.toISOString().split("T")[0];
      const response = await fetch(
        `${BASE_URL}/booking/getallbooking?user_id=${id}`
      );
      const result = await response.json();
      const data = result?.data || [];

      const filteredByDate = data.filter((item) =>
        item.date?.startsWith(formattedDate)
      );

      setBookings(data);
      setFiltered(filteredByDate);
    } catch (err) {
      console.error("Error fetching bookings:", err);
    }
  };


  const handleSearch = () => {
    const { groundId, bookingId, userName } = search;

    // Check if all fields are empty
    const isSearchEmpty = !groundId && !bookingId && !userName;

    if (isSearchEmpty) {
      // Show bookings only for selected date
      const formattedDate = date.toISOString().split("T")[0];
      const filteredByDate = bookings.filter((item) =>
        item.date?.startsWith(formattedDate)
      );
      setFiltered(filteredByDate);
      setPage(0);
      return;
    }

    const result = bookings.filter((item) =>
      item.ground_id?.toLowerCase().includes(groundId.toLowerCase()) &&
      item.book?.booking_id?.toLowerCase().includes(bookingId.toLowerCase()) &&
      item.name?.toLowerCase().includes(userName.toLowerCase())
    );

    setFiltered(result);
    setPage(0);
  };
  useEffect(() => {
    handleSearch();
  }, [search]);



  const handleDownload = async () => {
    try {
      const startStr = new Date(date.getFullYear(), date.getMonth(), 1).toISOString().split("T")[0];
      const endStr = new Date(date).toISOString().split("T")[0];

      const filteredByRange = bookings.filter(b => {
        const bookingDateStr = b.date?.split("T")[0];
        return bookingDateStr >= startStr && bookingDateStr <= endStr;
      });

      if (filteredByRange.length === 0) {
        alert("No bookings available for selected month.");
        return;
      }

      // Header & Info Lines
      const headingLines = [
        "PickYourGround - Monthly Booking Report",
        `Report Period: ${startStr} to ${endStr}`,
        "Generated by: PickYourGround App",
        ""
      ];

      const tableHeader = "Ground ID,Booking ID,User Name,Date,Slots,Mobile,Advance,Amount,Status";

      const rows = filteredByRange.map(b =>
        `${b.ground_id},${b.book?.booking_id},${b.name},${b.date},${formatSelectedSlotsDuration(b.slots.map(slot => ({ slot })))},${b.mobile},${b.prepaid},${b.book?.price},${b.paymentStatus === 'success' ? 'Paid' : 'Pending'}`
      );

      const totalAmount = filteredByRange.reduce((sum, b) => sum + (Number(b.book?.price) || 0), 0);
      const totalRow = `,,,,,,Total Amount,${totalAmount},`;

      const footerLines = [
        "",
        `Report Generated On: ${new Date().toLocaleString()}`,
        "Thank you for using PickYourGround!"
      ];

      const csvLines = [
        ...headingLines,
        tableHeader,
        ...rows,
        totalRow,
        ...footerLines
      ];

      const csvContent = csvLines.join("\n");

      // File name and path
      const filename = `Booking_Report_${startStr}_to_${endStr}.csv`;
      const fileUri = FileSystem.documentDirectory + filename;

      // Write file with correct encoding
      await FileSystem.writeAsStringAsync(fileUri, csvContent, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Share or alert
      if (await Sharing.isAvailableAsync()) {
        await Sharing.shareAsync(fileUri, {
          mimeType: 'text/csv',
          dialogTitle: 'Share Booking Report',
          UTI: 'public.comma-separated-values-text'
        });
      } else {
        alert(`CSV file saved to:\n${fileUri}`);
      }

    } catch (error) {
      console.error("Error generating CSV report:", error);
      alert("Download failed. Please try again.");
    }
  };






  const handlePaymentStatusChange = async (bookingId, newStatus) => {

    try {
      const response = await fetch(`${BASE_URL}/booking/updatepaymentstatus`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          booking_id: bookingId,
          paymentStatus: newStatus === "paid" ? "success" : "pending",
        }),
      });
      if (response.ok) {
        setBookings((prevBookings) =>
          prevBookings.map((booking) =>
            booking.book.booking_id === bookingId
              ? { ...booking, paymentStatus: newStatus === "paid" ? "success" : "pending" }
              : booking
          )
        );
        fetchBookings();
        // Optional: hide the dropdown immediately after change
        // setShowStatusOptions(null);

      } else {
        console.error("❌ Failed to update payment status");
      }
    } catch (error) {
      console.error("Error updating payment status:", error);
    } finally {
      setShowStatusOptions(null); // Close options
    }
  };


  const renderItem = ({ item }) => {
    const currentStatus = item.paymentStatus === 'success' ? 'paid' : 'pending';

    return (
      <View style={styles.rowItem}>
        <Text
          style={[styles.cell1, { color: 'blue', textDecorationLine: 'underline' }]}
          onPress={() => {
            setSelectedBooking(item);
            setModalVisible(true);
          }}>
          View
        </Text>
        <Text style={styles.cellname} numberOfLines={1} ellipsizeMode="tail">{item.name}</Text>
        <Text style={styles.cellmobile} numberOfLines={1} ellipsizeMode="tail">{item.mobile}</Text>
        <Text style={styles.cellamount} numberOfLines={1} ellipsizeMode="tail">{item.book?.price}</Text>
        <Text style={styles.celltime} numberOfLines={1} ellipsizeMode="tail">
          {formatSelectedSlotsDuration(item.slots.map(slot => ({ slot })))}
        </Text>



        <View style={styles.statusBox}>
          <View style={styles.toggleContainer}>
            <TouchableOpacity
              style={[
                styles.toggleButton,
                item.paymentStatus === 'pending' && styles.toggleButtonActivePending
              ]}
              onPress={() => handlePaymentStatusChange(item.book.booking_id, 'pending')}
            >
              <Text style={styles.toggleText}>N</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={[
                styles.toggleButton,
                item.paymentStatus === 'success' && styles.toggleButtonActivePaid
              ]}
              onPress={() => handlePaymentStatusChange(item.book.booking_id, 'paid')}
            >
              <Text style={styles.toggleText}>Y</Text>
            </TouchableOpacity>
          </View>
        </View>
        <Text style={styles.cell} numberOfLines={1} ellipsizeMode="tail">{item.book?.booking_id}</Text>
      </View>
    );
  };


  //  bookingDetails?.data[0]?.slots?.map(slot => ({ slot }))
  const formatSelectedSlotsDuration = (slots) => {
    if (!slots || slots.length === 0) return "";

    // Sort slots by start time
    const sortedSlots = [...slots].sort((a, b) => parseFloat(a.slot) - parseFloat(b.slot));

    const startSlot = parseFloat(sortedSlots[0].slot);
    const endSlot = parseFloat(sortedSlots[sortedSlots.length - 1].slot) + 0.5; // each slot is 0.5 hr

    // Format time for start and end slot
    const formatTime = (floatVal) => {
      const totalMinutes = floatVal * 60;
      const hour = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      const isPM = hour >= 12;
      const displayHour = hour % 12 === 0 ? 12 : hour % 12;
      const ampm = isPM ? "PM" : "AM";
      const minStr = minutes === 0 ? "00" : "30";
      return `${displayHour}:${minStr} ${ampm}`;
    };

    // Calculate total duration in minutes
    const totalDurationMins = (endSlot - startSlot) * 60;
    const hours = Math.floor(totalDurationMins / 60);
    const minutes = totalDurationMins % 60;

    // Format duration string, e.g., "2 hours 0 minutes"
    let durationStr = "";
    if (hours > 0) durationStr += `${hours} hour${hours > 1 ? "s" : ""}`;
    if (minutes > 0) durationStr += ` ${minutes} minutes`;
    // return `${formatTime(startSlot)} - ${formatTime(endSlot)} (${durationStr.trim()})`;
    return `${formatTime(startSlot)} - ${formatTime(endSlot)}`;
  };
  const renderEmptyComponent = () => (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'start', padding: 10 }}>
      <Text style={{ fontSize: 16, color: 'gray' }}>No data found</Text>
    </View>
  );

  useEffect(() => {
    getSummary();
  }, []);

  const getSummary = () => {
    if (!date) {
      return { totalSlots: 0, totalAmount: 0, monthlyAmount: 0 };
    }

    const selectedDateStr = date.toISOString().split("T")[0];

    // Get first and last day of the selected month
    const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
    const lastDayOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    lastDayOfMonth.setHours(23, 59, 59, 999);
    // Filter bookings for the selected date
    const selectedDateBookings = bookings.filter(booking => booking.date.split("T")[0] === selectedDateStr);

    // Filter bookings for the entire month
    const monthlyBookings = bookings.filter(booking => {
      const bookingDate = new Date(booking.date);
      return bookingDate >= firstDayOfMonth && bookingDate <= lastDayOfMonth;
    });

    // Calculate totals
    const totalSlots = selectedDateBookings.reduce((total, booking) => total + booking?.slots.length, 0);
    const totalAmount = selectedDateBookings.reduce((total, booking) => total + (booking.book ? booking.book.price : 0), 0);
    const monthlyAmount = monthlyBookings.reduce((total, booking) => total + (booking.book ? booking.book.price : 0), 0);

    return { totalSlots, totalAmount, monthlyAmount };
  };

  // Get the updated summary
  const { totalSlots, totalAmount, monthlyAmount } = getSummary();


  /////////////////////////////////POWER BI///////////////////////////////////////////
  // Assume you have an array `bookings` like the one you posted


  ///////////////////////////////////////////////////////////////////////////////////

  return (
   
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === "ios" ? "padding" : undefined}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.container}>

          <Text variant="titleLarge" style={styles.header}>Dashboard</Text>

          {/* Date Picker */}
          <View style={styles.dateRow}>

            {
              showDatePicker === true ? (
                <DateTimePicker
                  value={date}
                  mode="date"
                  display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                  onChange={(e, selectedDate) => {
                    setShowDatePicker(false);
                    if (selectedDate) setDate(selectedDate);
                  }}
                />) : (<TouchableOpacity onPress={() => setShowDatePicker(true)}>
                  <Text style={styles.dateText}>
                    Selected Date: <Text style={styles.clickableDate}>{date.toDateString()}</Text>
                  </Text>
                </TouchableOpacity>
              )
            }

          </View>

          {/* Search Filters */}
          <View style={styles.filterContainer}>
            {/* <TextInput
              label="Ground ID"
              mode="outlined"
              style={styles.input}
              value={search.groundId}
              onChangeText={(text) => setSearch((prev) => ({ ...prev, groundId: text }))}
            /> */}
            <TextInput
              label="Booking ID"
              mode="outlined"
              style={styles.input}
              value={search.bookingId}
              onChangeText={(text) => setSearch((prev) => ({ ...prev, bookingId: text }))}
            />
            <TextInput
              label="Name"
              mode="outlined"
              style={styles.input}
              value={search.userName}
              onChangeText={(text) => setSearch((prev) => ({ ...prev, userName: text }))}
            />
            {/* <Button icon="magnify" mode="contained" style={styles.searchButton} onPress={handleSearch}>
              Search
            </Button> */}
          </View>

          {/* Table Section */}
          <Card style={styles.tableCard}>
            <ScrollView horizontal>
              <View>
                <View style={styles.tableHeader}>
                  <Text style={styles.cell1}>View</Text>
                  <Text style={styles.cellname}>Name</Text>
                  <Text style={styles.cellmobile}>Mobile</Text>
                  {/* <Text style={styles.cell}>Advance</Text> */}
                  <Text style={styles.cellamount}>Amount</Text>
                  {/* <Text style={styles.cell}>Date</Text> */}
                  <Text style={styles.celltime}>Time</Text>
                  <Text style={styles.cellstatus}>Is Paid</Text>
                  <Text style={styles.cell}>B-ID</Text>
                </View>
                <FlatList
                  data={filtered.slice(page * itemsPerPage, (page + 1) * itemsPerPage)}
                  renderItem={renderItem}
                  keyExtractor={(item) => item.book?.booking_id || item._id}
                  ListEmptyComponent={renderEmptyComponent}
                />

                <View style={styles.paginationRow}>
                  <Button
                    mode="outlined"
                    disabled={page === 0}
                    onPress={() => setPage(page - 1)}
                  >
                    Previous
                  </Button>
                  <Text style={styles.pageInfo}>Page {page + 1} of {Math.ceil(filtered.length / itemsPerPage)}</Text>
                  <Button
                    mode="outlined"
                    disabled={(page + 1) * itemsPerPage >= filtered.length}
                    onPress={() => setPage(page + 1)}
                  >
                    Next
                  </Button>
                </View>
              </View>
            </ScrollView>
          </Card>
          <View style={styles.statsContainer}>
            <View style={styles.statBox}>
              <Text style={styles.statText}>Today's Slots: <Text style={styles.statStrong}>{totalSlots}</Text></Text>
            </View>

            <View style={styles.statBox}>
              <Text style={styles.statText}>
                Today Amount: <Text style={styles.statStrong}>₹{totalAmount}</Text>
              </Text>
            </View>

            <View style={styles.statBox}>
              <Text style={styles.statText}>
                Monthly Amount: <Text style={styles.statStrong}>₹{monthlyAmount}</Text>
              </Text>

            </View>
            <View>
              <Text style={styles.noteText}>
                Note: Monthly amount is consolidated from the 1st to the last day of the selected month.
              </Text>
            </View>
          </View>

          <Button mode="contained" style={styles.closeButton}
            onPress={handleDownload}>
            Download Report
          </Button>
          <Text style={styles.noteText}>
            Note: Downloads data from the 1st of the selected month to the selected date.
          </Text>
          {/* <Button mode="contained" onPress={handleDownloadToXLSX}>
            Download Excel
          </Button> */}

        </View>

        <Modal
          visible={modalVisible}
          transparent={true}
          animationType="slide"
          onRequestClose={() => setModalVisible(false)}
        >
          <View style={styles.modalOverlay}>
            <View style={styles.modalCard}>
              <Text style={styles.modalTitle}>📋 Booking Details</Text>

              {selectedBooking ? (
                <ScrollView>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Booking ID:</Text>
                    <Text style={styles.value}>{selectedBooking.book?.booking_id}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Name:</Text>
                    <Text style={styles.value}>{selectedBooking.name}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Mobile:</Text>
                    <Text style={styles.value}>{selectedBooking.mobile}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Amount:</Text>
                    <Text style={styles.value}>₹{selectedBooking.book?.price}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Date:</Text>
                    <Text style={styles.value}>{selectedBooking.date}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Slots:</Text>
                    <Text style={styles.value}>{formatSelectedSlotsDuration(selectedBooking.slots.map(slot => ({ slot })))}</Text>
                  </View>
                  <View style={styles.detailRow}>
                    <Text style={styles.label}>Payment Status:</Text>
                    <Text style={styles.value}>{selectedBooking.paymentStatus === 'success' ? 'Paid' : 'Pending'}</Text>
                  </View>
                </ScrollView>
              ) : (
                <Text style={{ color: '#777', marginVertical: 20 }}>No data found</Text>
              )}

              <Button
                mode="contained"
                style={styles.closeButton}
                onPress={() => setModalVisible(false)}
              >
                Close
              </Button>
            </View>
          </View>
        </Modal>

      </ScrollView>
       <Footer/>
    </KeyboardAvoidingView>
   
   
  );
};

const styles = StyleSheet.create({
  scrollContainer: {
    padding: 16,
  },
  container: {
    flex: 1,
    gap: 12,
  },
  header: {
    fontWeight: "bold",
    fontSize: 22,
    marginBottom: 12,
  },
  dateRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
     backgroundColor: '#f9f9f9',
  },
  filterContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 12,
    justifyContent: "space-between",
  },
  input: {
    flexGrow: 1,
    minWidth: 150,
  },
  searchButton: {
    alignSelf: "flex-start",

  },
  tableCard: {
    marginTop: 12,
    padding: 8,
    borderRadius: 8,
    backgroundColor: "#fff",
    elevation: 2,
  },
  tableHeader: {
    flexDirection: "row",
    // justifyContent: "center",
    paddingVertical: 10,
    backgroundColor: "#f0f0f0",
    borderTopLeftRadius: 6,
    borderTopRightRadius: 6,
  },
  rowItem: {
    flexDirection: "row",
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderColor: "#e0e0e0",
    backgroundColor: "#fff",
  },
  cell: {
    width: 150,               // Fixed width for consistency
    paddingLeft: 40,
    fontSize: 14,
    overflow: "hidden",
  },
  cellname: {
    width: 80,               // Fixed width for consistency
    paddingHorizontal: 8,
    fontSize: 14,
    overflow: "hidden",
  },
  cellmobile: {
    width: 120,               // Fixed width for consistency
    paddingHorizontal: 8,
    fontSize: 14,
    overflow: "hidden",
  },
  cell1: {
    width: 60,               // Fixed width for consistency
    paddingHorizontal: 8,
    fontSize: 14,
    overflow: "hidden",
  },
  cellamount: {
    width: 100,               // Fixed width for consistency
    paddingHorizontal: 8,
    fontSize: 14,
    overflow: "hidden",
  },
  celltime: {
    width: 150,               // Fixed width for consistency
    paddingHorizontal: 8,
    fontSize: 14,
    overflow: "hidden",
  },
  cellstatus: {
    width: 80,               // Fixed width for consistency
    paddingHorizontal: 0,
    fontSize: 14,
    overflow: "hidden",
  },
  paginationRow: {
    width: 300,
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 12,
  },
  pageInfo: {
    fontSize: 14,
    marginHorizontal: 20,
  },
  download: {
    marginTop: 20,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    flexWrap: 'wrap',
    marginTop: 10,
  },

  statBox: {
    marginHorizontal: 12,
    marginTop: 8,
  },

  statText: {
    fontSize: 14,
  },

  statStrong: {
    fontWeight: 'bold',
  },

  noteText: {
    fontSize: 12,
    color: 'gray',
    fontStyle: 'italic',
    marginTop: 4,
  },

  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalCard: {
    width: '90%',
    backgroundColor: '#fff',
    borderRadius: 15,
    padding: 20,
    elevation: 10,
    maxHeight: '80%',
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#006849',
    marginBottom: 15,
    textAlign: 'center',
  },
  detailRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 5,
  },
  label: {
    fontWeight: '600',
    color: '#333',
    fontSize: 14,
  },
  value: {
    fontWeight: '400',
    color: '#555',
    fontSize: 14,
    textAlign: 'right',
    maxWidth: '60%',
  },
  closeButton: {
    marginTop: 20,
    backgroundColor: '#006849',
  },
  pickerWrapper: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 6,
    marginVertical: 2,
    width: 100,
  },
  picker: {
    height: 35,
    fontSize: 12,
  },
  statusBox: {
    position: 'relative',
    minWidth: 100,
    alignItems: 'center',
  },

  statusBtn: {
    paddingVertical: 5,
    paddingHorizontal: 10,
    borderRadius: 6,
    borderWidth: 1,
    borderColor: '#ccc',
  },

  dropdownBox: {
    position: 'absolute',
    top: 35,
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ccc',
    zIndex: 999,
    borderRadius: 5,
    width: 100,
    elevation: 5,
  },

  optionText: {
    padding: 8,
    textAlign: 'center',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  //////spare////
  statusBox: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginVertical: 1,
  },
  toggleContainer: {
    flexDirection: 'row',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    overflow: 'hidden',
  },
  toggleButton: {
    paddingVertical: 2,
    paddingHorizontal: 4,
    backgroundColor: '#f2f2f2',
  },
  toggleButtonActivePending: {
    backgroundColor: '#ffe0b2',  //red
  },
  toggleButtonActivePaid: {
    backgroundColor: '#c8e6c9',
  },
  toggleText: {
    fontSize: 14,
    color: '#333',
    width: 30,
  },
  dateText: {
    fontSize: 16,
    color: '#333',
  },

  clickableDate: {
    color: '#006849', // Blue color (iOS-like)
    textDecorationLine: 'underline',
    fontWeight: 'bold',
  },
 
});

export default DashboardScreen;
